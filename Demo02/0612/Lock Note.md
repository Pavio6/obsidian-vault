1. 临界资源（Critical Resource）是在并发环境中必须互斥访问的共享资源。
2. sync.Mutex： Go 语言标准库 sync 包提供的 互斥锁，用于在多个 Goroutine（协程）之间安全地访问共享资源，防止数据竞争（Data Race）。
- 互斥性：同一时刻只有一个 Goroutine 能持有锁。
- 阻塞机制：未获取锁的 Goroutine 会被阻塞，直到锁被释放。
- 不可重入：同一个 Goroutine 不能重复加锁（会导致死锁）。
1. 幂等性：指对同一个操作重复执行多次，产生的结果与执行一次相同。
2. 原子性：指的是一系列操作要么全部成功执行，要么全部不执行，不可分割或中断。原子操作在执行过程中不会被其他线程或进程干扰，确保操作的完整性和一致性。
3. 自旋（Spin）：自旋是指线程在尝试获取锁或资源时，如果发现资源被占用（如锁已被其他线程持有），不会立即阻塞或放弃CPU，而是通过循环检查（忙等待）的方式持续尝试，直到成功获取资源。
4. CAS（compare and swap）：CAS 是一种原子操作，用于实现无锁并发控制。它的核心逻辑是：
	比较：检查某个内存位置的值是否等于预期值（oldValue）。
	交换：如果相等，则更新为新值（newValue）；否则不修改。

针对goroutine加锁时发现锁已被占用，策略有两种：
- 阻塞/唤醒（悲观锁）：将当前goroutine阻塞挂起，直到锁被释放后，以回调的方式将阻塞的goroutine重新唤醒，进行锁的争夺。
- 自旋/CAS（乐观锁）：基于自旋结合CAS的方式，重复校验锁的状态并尝试获取锁，始终把主动权掌握在自己手中。

**sync.Mutex结合两种方案，制定了一个锁升级的过程，反映了面对并发环境通过持续试探逐渐由乐观抓为悲观的态度。**

---
饥饿模式是展开对 公平性 的问题讨论。
- 饥饿：因为非公平机制的原因，导致Mutex阻塞队列中存在goroutine长时间取不到锁，从而陷入饥荒状态。
- 饥饿模式：当Mutex阻塞队列中存在处于饥饿态的goroutine时，会进入该模式，将抢锁流程由非公平机制转为公平机制。
**这是sync.Mutex为拯救陷入饥荒的老goroutine而启用的特殊机制，饥饿模式下，锁的所有权按照阻塞队列的顺序进行依次传递，老goroutine进行流程时不得抢锁，而是进入队列尾部排队。**

**信号量** 是一种用于多线程、多进程同步的底层机制，用于解决并发环境下的资源共享和任务协调问题。它的核心功能是控制对共享资源的访问权限，避免竞态条件和死锁。
**死锁(Deadlock)** 指多个goroutine互相等待对方释放资源，导致程序无法继续执行下去。



